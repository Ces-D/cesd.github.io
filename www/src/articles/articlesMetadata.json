[
  {
    "title": "Intro To Rtc",
    "description": " WebRTC (Web Real-Time Communications) is an open-source project that enables real-time voice, text, and video communication capabilities in web browsers and mobile devices. It uses JavaScript, APIs, and HTML5 to embed communications within web browsers, allowing users to initiate, monitor, and end P2P connections between devices for bidirectional data transfer. WebRTC supports various network scenarios including those with NAT firewalls, using STUN or TURN servers for IP translation. Before audio and video files are sent, they are compressed using codecs. Common use cases include video chats, healthcare, security, online gaming, and education. Pros of WebRTC include being open-source and free, supported by major browsers, eliminating manual integration work, adjusting communication quality, not requiring third-party components, and direct P2P connections. Cons include lack of support on some browsers and mobile devices, establishing P2P browser connections causing bandwidth issues, high maintenance costs for powerful servers, unclear security and privacy standards, and inconsistent video or audio quality over the internet due to lacking definitive quality of service standards.",
    "slug": "intro-to-rtc",
    "interest": {
      "curated_links": [],
      "related_posts": [],
      "category": "Other",
      "keywords": [
        "[\n{\"key\": \"WebRTC\"",
        "\"description\": \"open source project for real-time communication in web browsers\"}",
        "{\"key\": \"Real-time communication\"",
        "\"description\": \"voice",
        "text",
        "and video communication through APIs\"}",
        "{\"key\": \"P2P communications\"",
        "\"description\": \"direct device-to-device connections\"}",
        "{\"key\": \"STUN",
        "TURN servers\"",
        "\"description\": \"used for IP address translation and traffic relaying\"}",
        "{\"key\": \"Use cases\"",
        "\"description\": \"video chats",
        "telehealth",
        "home security",
        "online gaming",
        "online education\"}\n]"
      ]
    },
    "analytics": {
      "length_in_words": 793,
      "reading_time_in_minutes": 3,
      "published_on": "2024-02-27T19:16:06.112616971Z",
      "updated_on": "2024-02-27T19:16:06.112622639Z"
    }
  },
  {
    "title": "Reference And Borrowing",
    "description": " The article discusses the concepts of references and borrowing in Rust programming language. A reference is like a pointer but is guaranteed to point to a valid memory address for the lifetime of the reference. References are created using the `&` symbol and do not transfer ownership of the value they refer to.\n\nRust has immutable references by default, but mutable references can be created using the `mut` keyword. Mutable references have the restriction that only one variable can hold a mutable reference to a particular value at a time, which helps prevent data races.\n\nThe article also explains the concept of dangling references, which occur when a pointer refers to memory that has already been freed, leading to undefined behavior. Rust's borrow checker prevents this from happening at compile time.",
    "slug": "reference-and-borrowing",
    "interest": {
      "curated_links": [],
      "related_posts": [],
      "category": "Other",
      "keywords": [
        "[[\"References\"",
        "\"pointers with guaranteed validity\"]",
        "[\"Borrowing\"",
        "\"action of creating a reference\"]",
        "[\"Immutable References\"",
        "\"default type\"]",
        "[\"Mutable References\"",
        "\"controlled mutation\"]",
        "[\"Data Races\"",
        "\"potential issue with multiple pointers to same data\"]]"
      ]
    },
    "analytics": {
      "length_in_words": 435,
      "reading_time_in_minutes": 1,
      "published_on": "2024-03-21T20:13:32.239777371Z",
      "updated_on": "2024-03-21T20:13:32.239782763Z"
    }
  },
  {
    "title": "Web Sockets",
    "description": " WebSockets is a technology that allows for a persistent, single-socket connection between a web browser and a server for realtime data transfer. The process involves an opening handshake, data transmission over the connection, and closing the connection when needed. WebSocket has advantages such as low latency, less overhead, header compression, binary support, and cross-origin support. However, it also has disadvantages like requiring new server infrastructure, not being optimized for streaming media, not automatically recovering from terminated connections, and some environments blocking the connections.\n\nScalability of WebSockets is a complex issue for companies that use it to power realtime features for millions of end-users. Decisions include using vertical or horizontal scaling, dealing with unpredictable loads, managing WebSocket connections at scale, considering infrastructure costs, handling traffic spikes, and ensuring data integrity.\n\nWebSockets has alternatives like Server-Sent Events (SSE), HTTP Long Polling, MQTT, WebRTC, and WebTransport for realtime communication. To use WebSockets, one can create a connection using the `WebSocket` constructor, attach event handlers to the connection, send data using the `send()` method, and receive data via the `onmessage` callback. The latest spec also supports binary messages, sub-protocols, and extensions for additional functionality. Cross-origin communication is supported in WebSockets with servers specifying allowed origins and clients specifying willing protocols. Every new protocol deals with proxy servers.",
    "slug": "web-sockets",
    "interest": {
      "curated_links": [],
      "related_posts": [],
      "category": "Other",
      "keywords": [
        "[\n{\"keyword\": \"WebSocket\"",
        "\"definition\": \"a communication protocol for establishing persistent connections between a web browser and a server\"}",
        "{\"keyword\": \"opening handshake\"",
        "\"definition\": \"the process of establishing a WebSocket connection through an HTTP request/response exchange\"}",
        "{\"keyword\": \"data transmission\"",
        "\"definition\": \"exchanging messages (frames) over the persistent WebSocket connection after a successful handshake\"}",
        "{\"keyword\": \"closing handshake\"",
        "\"definition\": \"initiating the closing of a WebSocket connection by sending a close message\"}",
        "{\"keyword\": [\"Scalability\"",
        "\"horizontal scaling\"",
        "\"vertical scaling\"",
        "\"unpredictable loads\"",
        "\"WebSocket connections\"",
        "\"bandwidth\"",
        "\"traffic spikes\"",
        "\"automatic capacity\"",
        "\"data integrity\"]",
        "\"definition\": \"engineering decisions and technical trade-offs involved in scaling WebSockets for large applications\"}\n]"
      ]
    },
    "analytics": {
      "length_in_words": 1374,
      "reading_time_in_minutes": 5,
      "published_on": "2024-03-21T20:39:36.966999247Z",
      "updated_on": "2024-03-21T20:39:36.967003945Z"
    }
  }
]

